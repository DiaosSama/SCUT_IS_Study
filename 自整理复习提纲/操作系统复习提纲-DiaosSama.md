https://github.com/DiaosSama/SCUT_IS_Study

# 第二章 线程与进程

### 进程
1. 多道程序设计：当计算机开机后，许多进程将在电脑里同时运行
  - 各个进程轮流使用CPU，每个进程跑几十或几百毫秒
  - 任一时刻，只有一个进程在使用CPU
2. 进程的状态：
  - 运行态：正在使用CPU
  - 就绪态：在等待队列，随时可运行
  - 阻塞态：无法运行，直到某些条件满足
（状态转换图）
3. 进程的实现：
  - 操作系统维护一个进程表（Process Table），其中的每一个表项（进程控制块，PCB）对应一个进程
  - 进程从P1切换到P2时，P1的运行状态将保存到P1的PCB，而P2的状态则从相应的PCB中读出。使得P2能够接着之前的状态继续运行
  - 伪并行（Pseudo-parallelism）：进程间的快速切换给人以并行运行的假象
4. CPU利用率：
假设一个进程花费p比例的时间用于等待I/O，而内存中有n个进程，则CPU的利用率为：
$$
CPU利用率 = 1 - p^{n}
$$

---
1. 进程：计算机上所有可运行的软件，通常也包括操作系统，被组织成若干顺序进程，简称进程
2. 导致进程创建的事件：
  - 系统初始化
  - 由正在运行的进程创建
  - 用户请求创建
  - 批处理作业的初始化
3. 前台进程：与用户交互并完成相应工作的进程
4. 后台进程：非前台进程，具有某些专门的功能
5. 守护进程：在后台处理各种请求服务的进程
6. 导致进程终止的条件：
  - 正常退出（自愿）
  - 出错退出（自愿）：如：输入文件不存在
  - 严重错误（非自愿）：如：内存访问越界
  - 被其他进程杀死（非自愿）
7. 进程的层次结构
  - 父进程创建子进程，子进程创建子进程
  - Unix：有进程组的概念
  - Windows：没有层次结构，所有进程平等

### 线程
1. 什么是线程：
  - 线程是操作系统能够调度的最小单位（资源管理的单位为进程而非线程）
  - 线程是进程的组成部分
  - 每个进程至少包含一个线程
  - 一个进程可以包含多个线程
  - 线程间可以共享数据和内存
2. 为什么需要线程？
  - 响应时间：多个任务可以同时进行
  - 资源共享：线程间可以共享变量等资源
  - 经济：线程更容易创建和销毁
  - 在多核架构计算机上有用
3. 一些资源各线程独有，而一些资源则线程间共享
4. 实现线程的方式
  - 在用户空间中实现线程
    - 优点：速度快，可扩展，允许每个进程有自己定制的调度算法
    - 缺点：
      - 1）阻塞一个线程，导致阻塞该进程的所有线程
      - 2）无法在多核处理器上实现线程级别的并行
  - 在内核空间实现线程
    - 优点：可以单独阻塞某个进程的一个线程；可以在多核处理器上实现线程级别的并行
    - 缺点：线程管理速度慢，线程表非常大，占内存
  - 混合实现方式
    - 内核只感知到内核线程，且只调度内核级别的线程，而用户级别的线程则交给进程自己调度

### 进程间通信（IPC）
1. 竞争条件：多个进程访问一个共享数据，而数据最后的值由进程访问的先后顺序决定
2. 临界区：
  - 防止竞争条件的思想：禁止多个进程同时读和写共享数据
  - 好的解决方案满足的四个条件：
    - ① 没有进程同时在临界区
    - ② 不假设CPU的速度和数量
    - ③ 临界区外运行的进程不得阻塞其他进程
    - ④ 不会导致有进程永远在临界区外面等待
3. 忙等待：
  - 一个进程一直占用CPU测试循环的条件，直到测试条件为真
  - 浪费CPU
  - 导致优先级反转问题
4. 信号量
  - 一个信号量是一个包含两部分内容的数据结构：
    - （a）一个整数计数器，COUNT
    - （b）一个记录阻塞进程ID的队列，Q
  - 信号量有两个操作，UP和DOWN（PV）这两个操作是原子操作
  - 信号量通过引入阻塞避免了忙等待
5. 互斥量
  - 互斥量是一种特殊的信号量，它只有两种状态：unlock(0)或locked(1)

---
1. 忙等待的互斥：如何实现互斥
  - 屏蔽中断
  - 锁变量
  - 严格轮换法
  - Peterson解法
  - TSL指令（类似原子操作）
2. 睡眠与唤醒
  - 睡眠是一个系统调用，使得调用者阻塞自己直到另外的进程唤醒该进程
  - 唤醒调用唤醒指定的进程

### 进程调度
1. 调度程序（Scheduler）：用于决定哪个进程使用CPU的操作系统模块
2. 调度算法：调度模块使用的算法
（为了防止一个进程运行太长时间，计算机有周期性的时钟中断激活调度程序（比如20ms）
3. 抢占式的调度：运行的进程被临时中断，使得其他进程有机会使用CPU
4. 调度算法的目标：
  - 公平性：每个进程获得相同的CPU使用时间
  - 效率性：使CPU处于忙碌状态，做有用工
  - 响应时间：最小化从发出命令到得到响应的时间
  - 周转时间：最小化从提交任务到任务完成的时间
  - 吞吐量：最大化每小时完成的任务数量
5. 常用算法：
  - 先来先服务（FCFS）
  - 最短作业优先（SJF）：可以获得最优的平均最小等待时间
    - 难点：难以预先知道进程的CPU用时
    - 分为抢占式和非抢占式
  - 轮转调度
    - 特性：
      - 当时间片q增大时，算法将转化为FIFO
      - 当q减小时，算法将产生比较大比例的开销（频繁的上下文切换），因此，q应当设的合适
  - 优先级调度
    - 问题：饥饿——低优先级的进程可能会一直等待运行
    - 解决方案：引入老化技术——等待的进程的优先级会随着时间推移而增大
  - 保证调度
  - 彩票调度

### 线程调度
1. 进程调度算法亦可用于线程调度
2. 其中，轮转调度和优先级调度是最常用的线程调度算法
3. 线程调度有两种模式：用户级线程和内核线程（用户级线程可以引入与应用相关的调度机制）

### 经典的IPC问题
1. 读者写者问题
2. 哲学家就餐问题
3. 睡眠理发师问题

# 第三章 死锁

### 死锁
1. 定义：一个程序集处于死锁状态当集合中的每个进程都在等待一个资源，而该资源又被集合中另一个进程占有
2. 资源
  - 一个资源指的是一种能够被申请、被使用和被释放的对象。
  - 一个资源可以是一个硬件设备或者是一些信息
  - 分类：
    - 可抢占资源：可以从拥有它的进程中抢占而不会产生任何副作用（e.g. 内存）
    - 不可抢占资源：若从拥有它的进程中抢占将导致致命错误或相关的计算失败（e.g. 光盘刻录机）
3. 死锁的条件
  - 互斥：进程拥有的资源不可共享
  - 占有和等待：一个进程拥有某个资源并请求新的资源
  - 不可抢占：分配给进程的资源不可强制抢占，只能被拥有它的进程显示释放
  - 环路等待：存在一条环路，环路中每个进程都在等待下一个进程所占有的资源
4. 安全状态
  - 一个状态是安全的，如果存在某种调度顺序使得每个进程都可以结束即使所有进程都请求其所需的全部资源
  - （安全状态和不安全状态的区别在于系统是否可以保证所有进程都能结束）
5. 死锁检测——银行家算法
  - 判断是否满足该请求将导致不安全的状态。若会导致不安全的状态，则拒绝该请求。反之，则满足该请求。
  - 步骤：
    - Step 1：从矩阵R中寻找小于A的行，若没有这样的行，说明状态不安全
    - Step 2：若找到符合条件的行，说明该进程可以结束，将其标记并将其占有的资源释放
    - Step 3：重复步骤1和2直到所有行都被标记，说明状态安全
  - 理论上完美，实际上不使用，因为进程很难预知所需的资源

---
1. 死锁检测——资源分配图
2. 鸵鸟算法：
  - 方式：假装没事发生
  - 有一定合理性，如果死锁发生的概率非常小，而预防死锁的代价非常高
3. 死锁恢复
  - 利用抢占恢复：从某些进程中拿走资源并分配给另外的进程
  - 利用回滚恢复：周期性地对检查点进行检查，若发现死锁则将进程恢复到一个更早的状态
  - 通过杀死进程恢复：
    - 简单暴力的方式
    - 将环中的某个进程杀死并释放其资源
    - 其他进程获得资源得以运行
    - 一般选择杀死那些可以从头开始的进程
4. 饥饿
  - 定义：一个进程总是被剥夺处理其工作所必须的资源，进程一直在等待
  - 死锁会导致饥饿，但反之未必
  - 饥饿有可能会自动结束
5. 死锁预防
  - 破坏互斥条件
    - 几乎不可能，因为非共享的资源满足互斥条件
  - 破坏占有并等待条件
    - 使一个进程不必等待资源
    - 问题：进程可能无法在开始执行时知道所需的资源
  - 破坏不可抢占条件
  - 破坏环路等待条件
    - 保证一个进程任何时刻只能占用一个资源
    - 给资源编号，进程请求的资源必须按照资源编号的升序提出

# 第四章 内存管理

### 内存交换
1. 空闲内存管理
  - 使用位图的存储管理
    - 每个分配单元对应于位图中的一位，0表示空闲，1表示占用
    - 不足：查找位图中指定长度的连续0串是十分耗时的操作
  - 使用链表的存储管理
    - 链表的每个节点代表一个进程，或者是两个进程间的一块空闲区（包含起始位置与大小）
2. 四种用于存储管理的算法
  - 首次适配：从头搜索直到找到一个足够大的空闲区
  - 下次适配：从上次搜索结束的位置开始搜索直到找到一个足够大的空闲区
  - 最佳适配：搜索整个链表以找到最小的足够大的空闲区
  - 最差适配：搜索整个链表以找到最大的空闲区
  - 快速适配：为常用大小的空闲区维护单独的链表

### 虚拟内存
1. 问题：整个程序所需的内存远大于内存空间
2. 解决方案：
  - 覆盖：程序员把程序划分成多个片段，称为覆盖，但覆盖系统非常复杂，人工操作
  - 虚拟内存：操作系统仅保留当前正在使用内存的程序的一部分程序，全部工作交给计算机去做
3. 分页：实现虚拟内存的一种技术
4. 虚拟地址：一个由程序生成的地址
5. MMU（内存管理单元）：把虚拟地址映射成物理地址
6. 虚拟地址空间按照固定大小划分为（虚拟）页面。物理内存中对应的单元称为页框。
7. 调用一个没有映射的页面会使CPU陷入到操作系统，这个陷阱称为缺页中断（或缺页错误）。MMU会找到一个很少使用的页框且把它的内容写入磁盘（如果它不在磁盘上）。随后把需要访问的页面读到刚回收的页框中，修改映射关系，然后重新启动引起陷阱的指令
8. 页表：由页表给出虚拟地址与物理内存地址的关系
  - 大部分操作系统为每一个进程分配一个页表
  - 页表存储位置：
    - 用一个寄存器矩阵组成页表，当一个进程加载入页表时，这些寄存器会保存着这些页表
      - 优点：简单
      - 缺点：如果页表十分大而且每次转换内容时都把整个页表加载进来，代价十分高而且也严重影响了性能
    - 把页表放在内存中，一个单独的寄存器指向这个页面
      - 优点：内容转换代价低
      - 缺点：读页表项时会涉及一个或多个内存单元
9. 转换检测缓冲区（TLB）
  - 大部分程序都会访问一小部分的页
  - 提高方案：给计算机装配一个小的硬件设备，称为转换检测缓冲区（TLB）或相联存储器，以无需通过页表即可把虚拟地址映射称物理地址
  - 现代的简要指令集计算机（RISC）用软件来实现TLB的管理

#### 针对大内存的页表
1. 多级页表：
  - 减小页表大小，避免把全部页表一直保存在内存中，特别是那些不需要的页表
2. 倒排页表
  - 通常地，每个进程都会关联一个页表。这种方法的其中一个缺点是每个页表都可能含有数以百万计的表项
  - 倒排页表被用于解决这个问题。每个物理实际页框对应一个表项
  - 每一个表项由存在于真实内存的页的虚拟地址，以及占有这个页的进程的相关信息组成
  - 虽然倒排页表减少了需要存储在每个页表中的内存，但当一个页访问出现时，增加了搜索表所需的时间

#### 页面置换算法
1. 最优页面置换算法
  - 替换最久远才使用的页面
  - 性能最优，但是无法实现
2. 最近未使用页面置换算法（NRU）
  - 每个页面有访问位（R）和修改位（M）
    - 当页面被访问和修改时，相应位被设置
    - 当一个进程开始时，所有页面的访问位和修改位都置零
    - 每隔一定时间，访问位将置零
  - 根据上述位将页面分为如下四类：
    - Class 0：未访问，未修改
    - Class 1：未访问，已修改
    - Class 2：已访问，未修改
    - Class 3：已访问，已修改
  - **NRU思想：从最低编号的非空类中随机选择一个页面**
3. 先进先出页面置换算法（FIFO）
  - 优点：易于实现
  - 缺点：最先进入内存的页面可能是被频繁使用的页面
4. 第二次机会页面置换算法
  - 考察访问位：
    - 如果R=0，则替换该页
    - 如果R=1，设置R=0并将该页放在表尾，当成一个新页处理
5. 最近最少使用页面置换算法（LRU）
  - 假设最近使用的页面很快也会被使用（扔掉最久未使用的页面）
  - 软件方案：用一个链表将页面链接起来
    - 最近使用的在前面
    - 缺点：但是每次请求内存时都更新链表，开销非常大
  - 硬件方案：采用一个64位的计数器硬件
  - **LRU硬件通常不存在，因此我们通常用NFU（Not Frequently Used）来近似实现LRU（带老化与不带老化的比较）**
6. 工作集模型
  - 页面在请求的时候才调入——**请求调页**
  - 在进程运行的任何阶段，它都只访问较少的一部分页面，这种现象称为**局部性访问**
  - 进程最近一段时间访问的页面集合称为**工作集**
  - 若进程每执行几条指令就发生一次缺页中断，这种现象称为**颠簸**
  - 在进程运行之前，系统保持进程的工作集在内存中，这种方法称为**工作集模型**
  - 在进程运行前预先装入其工作集页面称为**预先调入**

  - 思想：考察最近访问的页面，将不在工作集中的页面置换出去
  - 目的：大大减少缺页中断率
  - 一个进程的工作集是该进程在过去的 τ 虚拟时间内访问的页面集（虚拟时间为该进程使用的CPU时间）
  - 扫描整个页表，置换符合如下条件的页面：
    - R=0，年龄大于 τ
    - R=0，年龄不大于 τ 但具有最大年龄
    - R=1，随机选择一个页面
7. 局部分配策略与全局分配策略
  - 全局分配策略对所有可运行的进程动态分配页框。局部分配策略只对单个进程分配页框。
  - 全局分配策略可以防止颠簸并保持页命中率在一定范围内
8. 页面大小
  - 小页面
    - 优点：有更少的内部碎片
    - 缺点：一个进程需要大量的页
  - 页面大小和内部碎片大小的均衡
    - s = 进程平均大小，以Byte为单位
    - p = 页的大小，以Byte为单位
    - e = 每个页表项的大小，以Byte为单位
$$
overhead(开销) = \frac{s·e}{p}+\frac{p}{2}
$$
最优条件
$$
p = \sqrt{2se}
$$

#### 分段
1. 段是逻辑上独立的地址空间
  - 段可能有不同的大小
  - 它们的大小可能会动态变化
  - 地址空间使用二维内存地址，由两部分组成：段和段的偏移量
  - 段可能有不同的保护
  - 允许进程之间共享过程和数据
2. 分段与分页结合（MULTICS）

---
1. 存储管理器：操作系统中管理分层存储体系的部分
2. 克服内存容量限制的两个方法：
  - 交换技术：即把一个进程完整调入内存，使该进程运行一段时间，然后把它存回磁盘
  - 虚拟内存：该策略甚至能使程序在只有一部分被调入内存的情况下运行
3. 内存紧缩：将交换技术在内存中产生的多个空闲区合并成一个大空闲区
4. 分页守护进程
  - 在大部分时间处于睡眠状态
  - 时不时醒来检查一下内存的状态
  - 当系统有很少空闲页框，使用页面置换算法置换出一些页面

# 第五章 文件系统

### 文件访问
1. 顺序访问
  - 从头按顺序读取文件
  - 不能跳过某些内容
  - 适合磁带存储介质
2. 随机访问
  - 可以按任意顺序读取字节/记录
  - 对实现数据库系统很重要

### 文件系统的实现
1. 文件系统布局：
  - 主引导程序记录（Master Boot Record，MBR）：磁盘的0号扇区，用于引导计算机
  - 分区表给出每个分区的起始和结束地址
2. 分区：
  - 第一块是引导块：引导装载操作系统
  - 超级块：包含文件系统的所有关键参数，在计算机启动时，或者在该文件系统首次使用时，超级块会被读入内存
  - 空闲空间管理：可以用指针列表或位图的方式给出
  - i-节点
  - 根目录
  - 文件和目录

### 文件的实现
1. 连续分配：每个文件作为一串连续的数据块存储
  - 优点：
    - 实现方式简单
    - 读数据的性能好
  - 缺点：
    - 产生磁盘碎片
    - 需要预先知道文件的大小
  - 实例：CD-ROM，DVD
2. 链表分配：为每个文件构造磁盘块链表
  - 缺点：
    - 随机访问的速度慢
    - 每个物理块中存储的数据不是2的整数幂次方（由于指针占去了一些字节）
3. 文件分配表（File Allocation Table，FAT）
  - 把每个物理块中的指针集中记录到一个表，放在内存中索引，该表称为文件分配表
  - 优点：
    - 整个物理块可以用于存储数据
    - 信息存储在内存中，访问快
  - 缺点：
    - 整个表都放在内存中，需要占用大量内存
4. i-节点
  - i-node（index-node）记录了文件的属性以及文件内容的存储地址

### 记录空闲块
1. 使用磁盘块链表：每个块中包含尽可能多的空闲磁盘块号
2. 使用位图：n个块的磁盘需要n位位图
  - 空闲块用1表示
  - 已分配块用0表示

### 文件系统备份
1. 备份：从灾难中恢复、挽救错误的操作
2. 两种备份策略
  - 物理转储：从第0块开始，将全部块复制存储
    - 优点：简单、快速
    - 缺点：无法增量存储，不能满足特定文件的恢复请求
  - 逻辑转储：从一个或几个指定的目录开始，递归地转储自某个基准日期后更改的文件和目录

### 文件系统一致性
1. 两类一致性检测：
  - 块一致性
  - 文件一致性

---
1. 文件结构：字节序列、记录序列、树
2. 文件系统用目录（或文件夹）记录文件的位置
  - 一级目录只有一个目录（root），包含所有文件
  - 二级目录包含root目录和用户目录
  - 层次目录：root目录和任意多的子目录
3. 虚拟文件系统：虚拟文件系统是操作系统内核的一层软件，它提供文件系统的接口给用户程序
  - 对不同的文件系统使用相同的API
  - 将文件操作与具体的文件系统实现分开
  - 具有更好的灵活性

# 第六章 输入输出

1. I/O设备
  - 块设备：所有传输以一个或多个完整的块为单位。比如，磁盘
  - 字符设备：以字符为单位发送或接收一个字符流。比如，键盘、鼠标、打印机等
2. 设备控制器
  - 每个I/O设备有两个组成部分
    - 物理部件
    - 电子部件
  - 电子部件指设备控制器（device controller）或适配器（adapter）
  - 任务：控制设备的物理运行；将序列字位流转化为字节块流；纠错操作；
  - 控制器与CPU的数据交互通过设备寄存器进行；为提高效率，设备通常还有数据缓冲区，如，视频控制器有视频RAM

### I/O模式

#### 物理I/O模式
1. 分类
  - 方法一：每个寄存器分配一个I/O端口号
    - 优点：I/O操作不会干扰内存操作
    - 缺点：增大程序设计难度，降低可靠性
  - 方法二：所有控制寄存器映射到内存空间——内存映射I/O
    - 优点：与内存访问统一
    - 缺点：总线竞争，增大系统设计难度
  - 混合方法：数据缓冲 -> 内存；控制寄存器 -> I/O端口
2. 根据CPU在I/O过程中的涉入程度：
  - 繁忙等待访问
  - 直接内存访问（DMA）

#### 逻辑I/O模式
1. 程序控制I/O（PIO）：控制CPU和外围设备之间数据传送的一种方法。数据传送的工作主要由CPU完成。
  - CPU要不断查询设备以了解它是否就绪准备接收另一个字符。这一行为经常称为轮询或忙等待
2. 中断驱动I/O：将CPU从繁忙等待中解脱出来
  - 步骤：
    - CPU初始化I/O并启动第一次I/O操作
    - CPU去忙别的活
    - 当I/O完成时，CPU将被中断
    - CPU处理中断
    - CPU恢复被中断的程序
  - 使用DMA的I/O
    - 优点：将中断的次数从打印每一个字符一次减少到打印每个缓冲区一次

### I/O软件层次
1. I/O软件通常包含四个层次，每一层具有一个要执行的定义明确的功能和一个定义明确的与邻近层次的接口
  - 中断处理程序
  - 设备驱动程序
  - 与设备无关的操作系统软件
  - 用户级I/O软件
2. 中断处理程序
  - 针对不同I/O硬件做出不同的响应处理；暴露窗口越小越好，让设备驱动程序负责中断响应
  - 中断需要花费相当多的CPU指令
3. 设备驱动程序
  - 直接驱动I/O进行输入输出操作的软件
  - 设备驱动程序与设备控制器的通信在总线上进行
  - 通常是内核的一部分
  - 多数操作系统都定义了标准的块设备和字符设备接口
4. 与设备无关的操作系统软件
  - I/O软件的一部分与设备无关，可共用起来，放在驱动程序之上，为用户提供统一的I/O接口
  - 统一接口：比如，一个程序可以访问任何I/O，而不需要预先知道设备的相关信息
  - 缓冲：提高数据传输率，防止溢出

### 磁盘
1. 分类：
  - 硬盘和软盘
  - 磁盘被组织成柱面、磁道和扇区的层次
2. 磁盘读写时间
  - 磁盘读写时间由三部分构成：
    - 寻道时间
    - 旋转延迟
    - 实际数据传输时间
3. 磁盘格式
  - 磁盘在能够使用之前，盘片必须经过低级格式化
    - 前导码：包含特定信息（柱面、扇区号等）以识别扇区
    - 数据部分：通常512字节
    - ECC：冗余信息，用于恢复错误，通常16字节
4. 柱面斜进（Cylinder Skew）
  - 目的：让磁盘在一次连续的操作中读取多个磁道而不丢失数据
5. 磁盘交错编号
  - 原因：读出扇区做出ECC计算后传送数据，所以无法连续读取多个扇区，需要额外等待时间
  - 解决方法：格式化磁盘时，以交错方式对扇区进行编号
6. 磁盘臂调度算法
  - 最短寻道优先（SSF）
  - 电梯算法

### 时钟硬件
1. 石英晶体产生周期性的信号（几百兆赫兹）
2. 两种模式：一次完成模式，方波模式
3. 时钟滴答：由可编程时钟产生的周期性中断

### 时钟软件
1. 时钟驱动的功能
  - 维护日时间
  - 防止进程超时运行
  - 处理用户进程提出的报警系统调用
  - 其他
2. 为了满足多个定时需求，操作系统需要基于单个物理时钟仿真多个虚拟时钟

### 电源管理
1. 省电的最常用办法是将设备设计成具有多种状态：工作、睡眠、休眠和关闭
2. 电压减半，时钟速度减半，功耗减少到1/4
3. 减少程序使用电量的方法：
  - 将彩色输出改为黑白
  - 利用无线通信调用其他设备完成任务
  - 采用较低的分辨率



---
